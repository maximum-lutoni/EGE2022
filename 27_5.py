# Дана последовательность из N целых положительных чисел. Необходимо выбрать такую подпоследовательность 
# подряд идущих чисел, чтобы их сумма была максимальной и делилась на 71, а также ее длину. Если таких 
# подпоследовательностей несколько, необходимо выбрать такую, у которой длина меньше.

# Описание входных и выходных данных

# Даны два входных файла (файл А и Файл В). В первой строке входных данных задаётся количество чисел N (2 ≤ N ≤ 10⁸).
# В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000. 

# В качестве результата программа должна напечатать одно число: длину найденной подпоследовательности.

""" 
    Будем отталкиваться от математики: 
    Мы знаем, что разность двух чисел, имеющих один и тот же остаток от деления на определенное число, кратна этому числу.
    Поэтому будем основываться на использовании массива сумм по остаткам для подсчёта промежуточных максимальных сумм.

    Посмотрим на примере. Нам нужна сумма кратная 5. Пусть есть последовательность:
    1 2 4 1 3 3 4
    Вся сумма равна 18. остаток 3. Значит для того чтобы она была кратна 5 нужно вычесть минимальную сумму кратную 3.
    А это сумма двух первых элементов. Получается подпоследовательность сумма которой кратна 5: 4 1 3 3 4

"""
# начнем как всегда с инициализации
f = open('27.txt')
n = int(f.readline())
ms = 0 # переменная для максимальной суммы
ml = 0 # переменная для длины
s = 0 # переменная для общей суммы последовательности
l = [10 ** 10] * 71 # массив минимальных сумм с индексом равным остатку %71
k = [0]*71 # массив индексов этих сумм


for i in range(n):
    x = int(f.readline())
    s += x # общая сумма
    p = s % 71 # остаток от деления суммы
    if s - l[p] > ms: # если разность между полученной суммой и минимальным суммой, которую нужно вычесть для кратности больше чем максимум
        ms = s - l[p] # заменяем максимум
        ml = i - k[p] # и длину
    elif s - l[p] == ms: # если равен
        ml = min(i - k[p],ml) # засеняем длину
    elif s < l[p]: # если меньше
        l[p] = s # то обновляем сумму с этим остатком
        k[p] = i # и индекс этой суммы
print(ml)
