S = "строка"
S1 = "стр"
S2 = "ока"

S[i]            # Обращение по индексу                          "S[4]" = "к"
S1 + S2         # Cложение строк(конкатенация):                 "cтр" + "ока" = "строка"
S[i:j:step]     # Извлечение среза​ от i до j с шагом step:      "cтрока"[1:4:2] = "то"
int(S)          # Приведение объекта к типу int​                 int("123") = 123              
len(S)          # Возвращает длину объекта (колличество элементов)​

S.replace(шаблон, замена, количество) # ​Замена шаблона в строке​                                              "информатика".replace("а","ко", 2) = 'информкотикко'
S.count(str)                          # Подсчет количества вхождений подстроки str в строку S​                "информатика".count("а") = 2
S.find(str, start)                    # Поиск подстроки str в строке S начиная с индекса start               "информатика".find("а") = 6
S.rfind(str, start)                   # (с начала для find, с конца для rfind)​                               "информатика".rfind("а") = 10
                                      # если элемент не найден возвращает -1                                 "информатика".find("б") = -1
if str in S:​                          # Проверка есть ли подстрока str в строке S​                            "тро" in "строка" == True
ord(символ)                           # Возвращает номер символа в кодировке Юникод​                          ord('a') = 97
chr(число)                            # Возвращает символ по указанному номеру в кодировке Юникод​            chr(97) = 'a'
S.split(разделитель)                  # Разбиение строки по указанному разделителю. Возвращается список​      "2 5".split() = ["2","5"]

S.isalpha()                           # Проверка на букву    'a'.isalpha() == True '2'.isalpha() == False 
S.isdigit()                           # Проверка на число    'a'.isdigit() == False '2'.isdigit() == True