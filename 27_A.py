# Неэффективные переборные программы
# Не прокатят для файла B
# Подходят для проверки эффективной программы

## Перебор произведений/сумм ##

# Инициализируем данные (подробнее в arrays)
N = int(input())
a = []
for i in range(N):
     a.append(int(input()))
# Перебераем неповторяющиеся соседние элементы    Для N = 5 следующие пары (0,1)(0,2)(0,3)(0,4)
for i in range(N-1):                            # (i,j)                    (1,2)(1,3)(1,4)
    for j in range (i + 1, N):                  # первое значение i        (2,3)(2,4)
        print(a[i] , a[j])                      # второе значение j        (3,4)

# Перебор значений с расстоянием в m между ними   Для N = 5 m = 2          (0,2)(0,3)(0,4)
for i in range(N - m):                          # пары вида (i,j)          (1,3)(1,4)
    for j in range (i + m, N):                  #                          (2,4)
        print(a[i] , a[j])                         


##############################################################################################################################

## E.G. ##
# На вход программе подаётся N положительных чисел, не превышающих 1000. Найдите наименьшую чётную сумму двух различных элементов массива.
# («различные элементы массива» обозначает, что у элементов массива должны быть различные индексы, при этом они могут быть равными по значению). 

N = int(input())
f = True                    # флаг для контрзначения
s = 0                       
a = []                                       
for i in range(N):                  
    a.append(int(input()))
for i in range (N - 1):             
    for j in range (i + 1, N):      
        if (a[i] + a[j]) % 2==0 and ((a[i] + a[j]) < s or f):  # проеряем на четность и ищем минимальную четную сумму
            s = a[i] + a[j]
            f = False              
print(s) 
##############################################################################################################################

## Задача на промежуток 6 минут ##

# Необходимо найти в заданной серии показаний прибора минимальное чётное произведение двух показаний, между моментами 
# передачи которых прошло не менее 6 минут. Если получить такое произведение не удаётся, ответ считается равным –1. 
# Программа должна вывести одно число – описанное в условии произведение, либо –1, если получить такое произведение не удаётся.

a = []
f = open("27_A.txt")
n = int(f.readline())	#получили количество чисел
m = 1000 * 1000 + 1	    # переменная для минимального произведения = макс_число*макс_число + 1
for i in range(n):	    # получили все числа в массив
      a.append(int(f.readline()))
for i in range(n – 6):	        # перебираем все возможные сочетания элементов с
    for j in range(i + 6, n):	# разностью в индексах 6
        # считаем произведения и ищем минимальное чётное
        if a[i] * a[j] % 2 == 0 and a[i] * a[j] < m:
            m = a[i] * a[j]
if m != 1000 * 1000 + 1: 	#проверяем, было ли найдено чётное произведение
     print(m)
else:
     print('–1')

##############################################################################################################################

# Дана последовательность из N целых положительных чисел. Необходимо выбрать из последовательности такую пару чисел a_i и a_j, 
# чтобы выполнялись следующие условия:
#   1. i < j, где i и j порядковые номера чисел в последовательности.
#   2. a_i > a_j – первый элемент пары должен быть больше второго элемента пары.
#   3. Сумма чисел a_i и a_j должна быть максимальна и кратна 120.

# В качестве результата программа должна напечатать одно число: сумму двух элементов последовательности a_i и a_j, 
# которые удовлетворяют заданным условиям. Гарантируется, что в последовательности есть хотя бы одна пара, удовлетворяющая всем условиям.

f = open("27_A.txt")
n = int(f.readline())
a = [int(f.readline()) for i in range(n)]
maxs = 0 #переменная для максимальной суммы
for i in range(n - 1):
    for j in range(i + 1, n):
        if a[i] > a[j] and (a[i] + a[j]) % 120 == 0:
            maxs = max(a[i] + a[j], maxs)
print(maxs)

##############################################################################################################################

# Дана последовательность из N целых положительных чисел. Необходимо выбрать такую подпоследовательность подряд идущих чисел, 
# чтобы их сумма была максимальной и делилась на 71, а также ее длину. Если таких подпоследовательностей несколько, необходимо 
# выбрать такую, у которой длина меньше.

# В качестве результата программа должна напечатать одно число: длину найденной подпоследовательности.

f = open('27_A.txt')
n = int(f.readline())
a = [int(f.readline()) for i in range(n)]
ms = 0  # сумма
ml = 0  # длина
for i in range(n-1):  # расстояние 1 поэтому (n-1)
    for j in range(i+1, n):
        s = sum(a[i:j + 1]) # сумма от i до j через срез массива
        if s % 71 == 0: # если сумма картна 71
            if s > ms: # и больше чем максимум
                ms = s # обновляем максимум
                ml = j - i + 1 # и длину
            if s == ms: # если равна
                ml = min(ml, j - i + 1) # обнавляем длину
print(ml)







