# Текстовый файл состоит не более чем из 106 символов X, Y и Z.
# Определите максимальную длину комбинации символов, удовлетворяющих маске X*Y, 
# где звёздочка обозначает любую последовательность символов, в том числе и пустую. 
# Для выполнения этого задания следует написать программу.


# Нас просят найти строку начинающуюся с X и заканчивающуюся Y
# Момент когда мы начинаем искать подстроку когда нам встретился X, Сверяем с максимумом когда нам встретился Y. При этом
# длина строки должна быть больше нуля (уже нашли X)

file = open("24.txt")
a = file.readline()
l, max_l = 0, 0
for i in range(len(a)):
    if a[i] == "X":
        l += 1
    elif l > 0:
        l += 1
        if a[i] == "Y":
            max_l = l
print(max_l)
file.close()

# второй вариант:
# делаем тоже самое, но при помощи методов find
print(a.rfind("Y")-a.find("X")+1)

###########################################################################################################################

# Текстовый файл состоит не более чем из 106 заглавных латинских букв (A, B, …, Z).
# Текст разбит на строки различной длины. Определите количество строк, в которых 
# встречается комбинация ABC*XYZ, где звёздочка обозначает любую последовательность
# символов, в том числе и пустую. Для выполнения этого задания следует написать программу

# Теперь у нас несколько сток в файле: используем readlines()
# Остальное анологично.

file = open("24.txt")
a = file.readlines()
k = 0
# перебор строк в списке a - созданом методом readlines(). В списке лежат строки из файла.
for line in a:
    # Если у нас вхождение ABC слева раньше чем вхождение XYZ справа значит подстрока есть. 
    # При этом нужно удостовериться, что ABC есть в этой строке. Так как если нет, то -1 меньше чем любой индекс
    if line.find("ABC") < line.rfind("XYZ") and "ABC" in line:
        k += 1
print(k)
file.close()

###########################################################################################################################

# Текстовый файл состоит не более чем из 106 заглавных латинских букв (A, B, …, Z). Текст разбит на строки различной длины. 
# Определите количество строк, в которых буква K встречается чаще буквы L.
# Для выполнения этого задания следует написать программу.

# Нужно посчитать колличество букв => метод .count() в помощь

file = open("24.txt")
a = file.readlines()
k = 0
for line in a:
    if line.count("K") > line.count("L"):
        k += 1
print(k)
file.close()

###########################################################################################################################

# Текстовый файл состоит не более, чем из 107 строчных букв английского алфавита. 
# Найдите максимальную длину подстроки, в которой символы A и D не стоят рядом

# Опять одна строка. Опять соседние символы.
# Если А и D стоят рядом обнуляем переменную для длины подстроки. В противном случае подстрока продолжается.

file = open("24.txt")
a = file.readline()
l = 0
max_l = 0
for i in range(len(a) - 1):
    if (a[i] == "D" and a[i + 1] == "A") or (a[i] == "A" 
and a[i + 1] == "D"):
        l += 1
        max_l = max(l, max_l)
        l = 0
    else:
        l += 1
        max_l = max(l, max_l)
print(max_l)
file.close()








