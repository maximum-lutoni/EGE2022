# Компания купила для своих сотрудников места в нескольких подряд идущих рядах в кинотеатре. Известно, какие места уже распределены между 
# сотрудниками. Найдите ряд с наибольшим номером, в котором есть два соседних места, таких что слева и справа от них в том же ряду места 
# уже распределены (заняты). Гарантируется, что есть хотя бы один ряд, удовлетворяющий этому условию. В ответе запишите два целых числа: 
# номер ряда и наименьший номер места из найденных в этом ряду подходящих пар свободных мест.

# Входные данные
# В первой строке входного файла находится число: N – количество занятых мест (натуральное число, не превышающее 10 000). 
# Каждая из следующих N строк содержит два натуральных числа, не превышающих 100 000: номер ряда и номер занятого места.

# Выходные данные
# Два целых неотрицательных числа: номер ряда и наименьший номер места в выбранной паре.

# Пример входного файла:
# 7
# 40 3
# 40 6
# 60 33
# 50 125
# 50 128
# 50 64
# 50 67
# Условию задачи удовлетворяют три пары чисел: 40 и 4, 50 и 126, 50 и 65. Ответ для приведенного пример: 50 65

""" Посмотрим на примере:
ряд 40 место 2 3 4 5 6 7
             * ! * * ! *
ряд 50 место 64 65 66 67 ... 125 126 127 128
              !  *  *  !       !   *   *   !
ряд 60 место 32 33 34
              *  !  *

Как можем заметить места на которые мы будем сажать сотружников нахлдятся между занятыми различающимеся на 3. 
При этом нам нужно выбрать наибольший ряд и наименьшее место.
Нам нужно отортировать данные по ряду. А в ряде по месту. Тогда задача решается легко(Нужно лишь найти чтобы между соседними занятыми местами было расстояние 3)
В решении нам опять поможет соритировка. Двумерный массив a[i][j] вначале сортируется по первому элеметну, а потом по второму.
Но есть еще одна особенность нам нужно одно максимально другое минимальное. Для этого инвертируем значения места с минусом.
(Тогда сортируя по возрастанию, мы будем получать значения по убыванию)
"""

# инициализация данных
f = open("26.txt") # открываем файл
N = int(f.readline()) # количество занятых мест
p = [] # двумерный массив для хранения информации о рядах и местах
for i in range(N):
    l = f.readline().split(' ') # читаем строку с текущим рядом и местом
    l[0] = int(l[0])  # записываем номер ряда
    l[1] = -int(l[1]) # и номер места со знаком «-» для минимальности
    p.append(l) # добавляем данные в массив

# Проверяем соседние места
p.sort(reverse=True) # сортируем массив по убыванию
for i in range(len(p) - 1): # перебираем до предпоследнего элемента
    if p[i][0] == p[i + 1][0] and p[i][1] - p[i+1][1] == 3: # если места на одинаковом ряду и разница между ними равна 3
        print(p[i][0], -p[i+1][1] + 1) # то выводим ряд и наименьшее место со знаком «-»
        break
